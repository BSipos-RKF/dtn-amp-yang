<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY AMPMODNAME "amp">
]>
<?rfc toc="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude"
     ipr="trust200902" 
     docName="draft-bsipos-dtn-amp-yang-00"
     category="exp">
  <front>
    <title abbrev="A YANG profile for AMP ADMs">
      A YANG profile for defining
      Asynchronous Management Protocol
      Application Data Models
    </title>
    <author initials="B." surname="Sipos" fullname="Brian Sipos">
      <organization abbrev="RKF Engineering">
        RKF Engineering Solutions, LLC
      </organization>
      <address>
        <postal>
        <street>1229 19th Street NW</street>
        <city>Wasington</city>
        <region>DC</region>
        <code>20036</code>
        <country>US</country>
        </postal>
        <email>BSipos@rkf-eng.com</email>
      </address>
    </author>
    <author initials="E." surname="Birrane" fullname="Edward Birrane"
            role="editor">
      <organization abbrev="JHU APL">
        Johns Hopkins University Applied Physics Laboratory
      </organization>
      <address>
        <email>Edward.Birrane@jhuapl.edu</email>
      </address>
    </author>
    <date year="2016" month="March"/>
    <workgroup>Internet Research Task Force (IRTF)</workgroup>

    <abstract><t>
      This document specifies a YANG profile for defining
      Application Data Model (ADM) schema for the
      Asynchronous Management Protocol (AMP).
      The AMP has no relation to NETCONF; YANG is used here only for
      its language syntax, and its module and type systems.
    </t></abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
      This profile uses YANG as an encoding for the management schema and
      makes use of the YANG module and type systems.
      The fact that YANG is also used to specify data models for the
      NETCONF protocol has no direct influence over this use of YANG
      to specify data models for AMP.
      </t>
      <t>
      
      </t>

      <section title="Requirements Language">
        <t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.
        </t>
      </section>
    </section>
    
    <section title="Application Data Models">
      <t>
      An AMP application SHALL define its Application Data Model (ADM) by means
      of a YANG module which imports and uses "&AMPMODNAME;" module extensions.
      An official Pyang tool <xref target="pyang"/> plugin SHOULD be used
      to validate the contents of an ADM YANG module.
      </t>
      
      <section title="Module Restrictions">
        <t>
        A YANG module which defines an AMP ADM SHALL NOT be used to also define
        a data model for NETCONF or any other non-AMP protocol.
        It may be syntatically allowable to mix models for multiple protocols
        but it decreases the intelligability of the module for either purpose.
        </t>
        <t>
        A YANG module which defines an AMP ADM SHALL NOT contain any
        "default" statements.
        </t>
      </section>
      
      <section title="OID Assignment" anchor="oid-assign">
        <t>
        For each ADM-specific YANG statement which requires an OID to be
        assigned to it, it is possible to use one of the
        "fulloid", "suboid", or "compressoid" substatements to make that
        assignment.
        Not all of the OID assignment substatements are available in all
        contexts, so following the allowed substatement table is important.
        </t>
        <t>
        The types of OID assignments are:
          <list style="symbols">
            <t>
            Full OIDs can be used in any situation where an OID is needed.
            </t>
            <t>
            Compressed OIDs can also be used in any situation where an OID is
            needed, but require the use of a module-unique OID nickname ID.
            </t>
            <t>
            Sub-OIDs can be used where the OID being assigned is relative to the
            structural (module-statement-wise) parent of the assignment.
            </t>
          </list>
          An ADM SHOULD make use of sub-OIDs where possible, both to avoid
          typos possible with full OIDs and to avoid nickname assignment for
          every group within the ADM.
          Using sub-OIDs also guarantees that the tree structure of the ADM
          module matches one-for-one with the OID tree.
        </t>
      </section>
    </section>

    <section title="YANG Types for AMP">
      <t>
      This section specifies how AMP types interact with native YANG types.
      All AMP data types are sub-typed from YANG native types solely
      for the purpose of providing a baseline of behavior for YANG
      parsers.
      Any YANG module which defines an AMP ADM SHALL only use types 
      (or derived types) from the "&AMPMODNAME;" module.
      </t>

      <section anchor="types.integer" title="The Integer Types">
        <t>
        The AMP types of "BYTE", "INT", "UINT", "VAST", and "UVAST" are derived
        directly from the built-in YANG type of the same numeric domain.
        There is no functional difference between these types and the native
        types, other than the namespace of these types.
        Using AMP-specific names allows ADM module authors to keep consistent
        terminology between textual specification and YANG specification.
        </t>
        <t>
        The "SDNV" type is derived from YANG "binary" type due to its domain
        being larger than any of the built-in YANG types.
        </t>
      </section>

      <section anchor="types.float" title="The Floating Point Types">
        <t>
        The AMP types of "REAL32" and "REAL64" are derived from YANG "binary"
        type because the built-in floating point type is not a clear
        superset of the floating point types of 
        <xref target="I-D.birrane-dtn-amp"/>.
        </t>
      </section>
      
      <section anchor="types.othersimple" title="Other Simple Types">
        <t>
        The "SDNV" type is derived from YANG "binary" type due to its domain
        being larger than any of the built-in YANG numeric types.
        </t>
        <t>
        The "TS" type is also derived from YANG "binary" type due to the
        more complex encoding semantics of the TS type.
        </t>
      </section>

      <section anchor="types.compound" title="The Compound Types">
        <t>
        The "STR" type is derived from the YANG "string" type only because
        they both are intended to have the semantics of human-readable text.
        An ADM SHOULD NOT use the amp:STR type for any data other than text
        encoded with UTF-8 (see <xref target="RFC3629"/>).
        The encoding of "STR" type is wholy unrelated to any NETCONF use
        of the YANG "string" type.
        </t>
        <t>
        The "BLOB" type is derived from YANG "binary" type.
        The BLOB is the simplest AMP-specific type which is encoded using
        internal sub-items (the size separate from the bytes).
        </t>
        <t>
        The "DC" and "TDC" types are also derived from YANG "binary" type
        for lack of specific YANG mechanism for type decomposition.
        </t>
      </section>

      <section anchor="types.oids" title="Object Identifier Types">
        <t>
        The "MID" type is derived from YANG "binary" type due to its combined
        use of bit patterns (in its header) and BER-encoded data.
        </t>
        <t>
        The "MC" type is also derived from YANG "binary" type
        for lack of specific YANG mechanism for type decomposition.
        </t>
      </section>

      <section title="Applicaiton Module Subtyping">
        <t>
        An ADM SHOULD subtype any numeric type in order to apply additional
        semantic context to the numerical values
        (similar to the SMIv2 CounterXX and GaugeXX <xref target="RFC2578"/>).
        An ADM SHOULD make use of the YANG "units" substatement when
        numeric types are used (within either a typedef or a type-use).
        </t>
        <t>
        An ADM SHOULD subtype the BLOB type in order to identify
        application-specific encoding formats.
        Using plain BLOB types within an ADM is discouraged due to the
        opaqueness of the 
        </t>
        <t>
        Any ADM subtype SHALL have no effect on the value encoding of AMP.
        Subtypes are purely used to assist applications in managing
        value semantics.
        Any ADM subtype SHALL include a description substatement explaining
        the purpose of the subtype.
        </t>
      </section>

    </section>
    
    <section title="YANG Extensions for AMP">
      <t>
      This section specifies how AMP extension statements interact with
      native YANG statements within an application YANG module.
      </t>

      <section anchor="stmt.fulloid" title="The fulloid Extension Statement">
        <t>
        A "fulloid" statement is used to anchor an item in the OID
        tree.
        The value of a fulloid is the dotted-numeric notation of the OID
        value. A fulloid value must not be empty.
        Any substatements which are sibling to a "fulloid" will be relative
        to that OID root for the purposes of "suboid" processing.
        </t>
        <t>
        The format of a fulloid argument is a string of period-separated
        numeric components.
        </t>
        <texttable anchor="stmt.fulloid.subs" title="fulloid Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
        </texttable>
      </section>

      <section anchor="stmt.suboid" title="The suboid Extension Statement">
        <t>
        A "suboid" statement is used to define an item's OID relative
        to a sibling statement's full OID.
        The value of a suboid is the dotted-numeric notation of the OID
        parts under the full OID. A suboid value must not be empty.
        </t>
        <t>
        The format of a suboid argument is the same as a fulloid argument.
        The interpretation of a suboid depends upon the context of the 
        statement.
        </t>
        <texttable anchor="stmt.suboid.subs" title="suboid Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
        </texttable>
      </section>

      <section anchor="stmt.nickname" title="The nickname Extension Statement">
        <t>
        A "nickname" statement is used to define an application-specific
        numeric identifier for a full OID prefix.
        The nickname is used by both the AMP agent and manager to shorten
        OID encoding.
        </t>
        <t>
        The format of a nickname argument is a single non-negative integer
        value.
        Each nickname is defined within the namespace of the ADM module.
        </t>
        <texttable anchor="stmt.nickname.subs" title="nickname Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
          <c>fulloid</c>
          <c>1</c>
        </texttable>
      </section>

      <section anchor="stmt.compressoid" title="The compressoid Extension Statement">
        <t>
        A "compressoid" statement is used to define a full OID based on
        a module-specific nickname (see <xref target="stmt.nickname"/>) as
        a prefix and a suboid suffix.
        </t>
        <t>
        The format of a compressoid argument is a nickname value 
        (see <xref target="stmt.nickname"/>) within square brackets
        followed by a suboid string.
        </t>
        <texttable anchor="stmt.compressoid.subs" title="compressoid Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
        </texttable>
      </section>

      <section anchor="stmt.group" title="The group Extension Statement">
        <t>
        The "group" statement is used to define a grouping of other items
        within the ADM.
        Each group is assigned an OID (see <xref target="oid-assign"/>) 
        and used as an OID anchor for its substatements.
        </t>
        <t>
        The order of substatements within a group is not significant.
        Only the OID assignment of each item is significant.
        </t>
        <texttable anchor="stmt.group.subs" title="group Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
          <c>reference</c>
          <c>0..1</c>
          <c>status</c>
          <c>0..1</c>
          
          <c>fulloid | suboid | compressoid</c>
          <c>1</c>
          <c>group</c>
          <c>0..*</c>
          <c>primitive</c>
          <c>0..*</c>
          <c>control</c>
          <c>0..*</c>
          <c>report</c>
          <c>0..*</c>
          <c>macro</c>
          <c>0..*</c>
          <c>operator</c>
          <c>0..*</c>
        </texttable>
      </section>

      <section anchor="stmt.primitive" title="The primitive Extension Statement">
        <t>
        The "primitive" statement is used to define an atomic value within
        an ADM.
        Each primitive is assigned an OID (see <xref target="oid-assign"/>)
        and a type.
        The primitive has different semantics from the YANG "leaf" statement
        due to the lack of secondary (non-type) attributes (e.g. config/state
        distinction).
        All primitive objects are state; any configuration is performed
        via "control" statements.
        </t>
        <texttable anchor="stmt.primitive.subs" title="primitive Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
          <c>reference</c>
          <c>0..1</c>
          <c>status</c>
          <c>0..1</c>
          
          <c>fulloid | suboid | compressoid</c>
          <c>1</c>
          <c>type</c>
          <c>1</c>
          <c>units</c>
          <c>0..1</c>
        </texttable>
      </section>

      <section anchor="stmt.control" title="The control Extension Statement">
        <t>
        The "control" statement is used to define an available control
        within the ADM.
        Each control is assigned an OID (see <xref target="oid-assign"/>)
        and an ordered list of parmeter and result items.
        The control has different semantics from the YANG "rpc" statement
        due to the difference in protocol encoding and to the asynchronous
        nature of the AMP.
        </t>
        <t>
        Each control is parameterized by some number of parameters
        (see <xref target="stmt.parameter"/>) and some number of results
        (see <xref target="stmt.result"/>).
        There is no provision in an ADM for specifying alternative parameters
        or alternative results (i.e. no parameters are optional).
        </t>
        <texttable anchor="stmt.control.subs" title="control Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
          <c>reference</c>
          <c>0..1</c>
          <c>status</c>
          <c>0..1</c>
          
          <c>fulloid | suboid | compressoid</c>
          <c>1</c>
          <c>parameter</c>
          <c>0..*</c>
          <c>result</c>
          <c>0..*</c>
        </texttable>
      </section>

      <section anchor="stmt.parameter" title="The parameter Extension Statement">
        <t>
        The "parameter" statement is used to define single expected parameter
        of a "control" statement.
        In the AMP each control has a fixed number of typed parameters, there
        is no provision for overloaded controls which take variable numbers
        of parameters.
        </t>
        <t>
        A control parameter is an atomic value with a distinct type,
        but has no distinct OID.
        The parameter statement's argument is used as the parameter's name.
        Within a single control, each parameter name SHALL be unique.
        The parameter name is not related to any AMP encoding, so is useful
        only for the sake of identifying the parameter within the ADM.
        </t>
        <texttable anchor="stmt.parameter.subs" title="parameter Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
          <c>type</c>
          <c>1</c>
          <c>units</c>
          <c>0..1</c>
        </texttable>
      </section>

      <section anchor="stmt.result" title="The result Extension Statement">
        <t>
        The "result" statement is used to define single expected result
        of a "control" statement.
        In the AMP each control has a fixed number of typed results, there
        is no provision for overloaded controls which yield variable numbers
        of results.
        </t>
        <t>
        A control result is an atomic value with a distinct type,
        but has no distinct OID.
        The result statement's argument is used as the result's name.
        Within a single control, each result name SHALL be unique.
        The result name is not related to any AMP encoding, so is useful
        only for the sake of identifying the result within the ADM.
        </t>
        <texttable anchor="stmt.result.subs" title="result Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
          <c>type</c>
          <c>1</c>
          <c>units</c>
          <c>0..1</c>
        </texttable>
      </section>

      <section anchor="stmt.report" title="The report Extension Statement">
        <t>
        The "report" statement is used to define the contents of an AMP 
        report, but does not define when any instances of the report may
        be created.
        Each report is assigned an OID (see <xref target="oid-assign"/>)
        and an ordered list of content items.
        Asynchronous reporting is a distinct feature of the AMP from
        other management protocols.
        </t>
        <t>
        Each report is parameterized by some number of items which are to
        be contained in corresponding report instances
        (see <xref target="stmt.reportitem"/>).
        There is no provision in an ADM for specifying alternative report
        contents.
        </t>
        <texttable anchor="stmt.report.subs" title="report Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
          <c>reference</c>
          <c>0..1</c>
          <c>status</c>
          <c>0..1</c>
          
          <c>fulloid | suboid | compressoid</c>
          <c>1</c>
          <c>reportitem</c>
          <c>0..*</c>
        </texttable>
      </section>

      <section anchor="stmt.reportitem" title="The reportitem Extension Statement">
        <t>
        The "reportitem" statement is used to define single expected item
        within a report instance.
        In the AMP each report has a fixed number of typed items, there
        is no provision for overloaded reports which yield variable numbers
        of items.
        </t>
        <t>
        A reportitem is an atomic value with a distinct OID of the primitive
        to be included in a report instance.
        A reportitem has no type of its own.
        The reportitem statement's argument is used as the item's name.
        Within a single report, each reportitem name SHALL be unique.
        The reportitem name is not related to any AMP encoding, so is useful
        only for the sake of identifying the item within the ADM.
        </t>
        <texttable anchor="stmt.reportitem.subs" title="reportitem Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
          <c>fulloid | compressoid</c>
          <c>1</c>
        </texttable>
      </section>

      <section anchor="stmt.macro" title="The macro Extension Statement">
        <t>
        The "macro" statement is used to declare an AMP macro within an ADM.
        </t>
        <t>
        //FIXME: what value is there in the inline definition?
        </t>
        <texttable anchor="stmt.macro.subs" title="macro Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
          <c>reference</c>
          <c>0..1</c>
          <c>status</c>
          <c>0..1</c>
          
          <c>fulloid | suboid | compressoid</c>
          <c>1</c>
        </texttable>
      </section>

      <section anchor="stmt.operator" title="The operator Extension Statement">
        <t>
        The "operator" statement is used to define the syntax of an ADM 
        operator (for use in expressions).
        Each operator is assigned an OID (see <xref target="oid-assign"/>)
        and an ordered list of operands.
        </t>
        <t>
        Each operator is parameterized by some number of items which are to
        be used as operands at statement execution time.
        (see <xref target="stmt.operand"/>).
        </t>
        <texttable anchor="stmt.operator.subs" title="operator Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
          <c>reference</c>
          <c>0..1</c>
          <c>status</c>
          <c>0..1</c>
          
          <c>fulloid | suboid | compressoid</c>
          <c>1</c>
          <c>operand</c>
          <c>0..*</c>
        </texttable>
      </section>

      <section anchor="stmt.operand" title="The operand Extension Statement">
        <t>
        The "operand" statement is used to define single expected operand
        within an operator statement.
        In the AMP each operation has a fixed number of untyped operands.
        There is no provision for overloaded operators which take 
        variable numbers of operands.
        </t>
        <t>
        An operand is an atomic value with no associated OID or type.
        The operand statement's argument is used as the item's name.
        Within a single operator, each operand name SHALL be unique.
        The operand name is not related to any AMP encoding, so is useful
        only for the sake of identifying the item within the ADM.
        </t>
        <texttable anchor="stmt.operand.subs" title="operand Substatements">
          <ttcol>substatement</ttcol>
          <ttcol>cardinality</ttcol>
          
          <c>description</c>
          <c>0..1</c>
        </texttable>
      </section>

    </section>

    <section title="IANA Considerations">
      <t>
This memo does not require any IANA assignments.
      </t>
    </section>

    <section title="Security Considerations">
      <t>
This memo only defines a mechanism to specify an application schema, it does
not impose any limitations or requirements on the contents of that schema.
      </t>
    </section>
  </middle>

  <back>
    <references title='Normative References'>
      <?rfc include="reference.RFC.2119.xml"?>
      <?rfc include="reference.RFC.3629.xml"?>
      <?rfc include="reference.I-D.birrane-dtn-amp.xml"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.2578.xml"?>
      <?rfc include="reference.I-D.birrane-dtn-ama.xml"?>
      <reference anchor='pyang'>
        <front>
          <title>An extensible YANG validator and converter in python</title>
          <author initials='M.' surname='Bjorklund'
                  fullname='Martin Bjorklund'>
            <address>
              <uri>http://code.google.com/p/pyang/</uri>
            </address>
          </author>
          <date month='October' year='2010' />
        </front>
        <seriesInfo name='RFC' value='2200' />
        <seriesInfo name='STD' value='1' />
        <format type='TXT' octets='94506'
                target='ftp://ftp.isi.edu/in-notes/rfc2200.txt' />
      </reference>
      <!-- <?rfc include="reference.IEEE.754.2008.xml"?> -->
      <?rfc include="reference.CCITT.X690.2002.xml"?>
    </references>
  
    <section title="YANG Definitions">
      <t>
      The contents of this section is the machine-readable specification
      of this YANG module.
      </t>
      
      <section title="AMP Module">
        <t>
        The following YANG definition is the top-level "amp" module.
        </t>
        <figure>
        <artwork>&lt;CODE BEGINS&gt; file "amp-adm.yang"

<xi:include parse="text" href="amp-adm.yang" />
&lt;CODE ENDS&gt;</artwork>
        </figure>
      </section>
      
      <section title="AMP Type Submodule">
        <t>
        The following YANG definition includes types specific to AMP.
        </t>
        <figure>
        <artwork>&lt;CODE BEGINS&gt; file "amp-types.yang"

<xi:include parse="text" href="amp-types.yang" />
&lt;CODE ENDS&gt;</artwork>
        </figure>
      </section>
      
      <section title="AMP Extensions Submodule">
        <t>
        The following YANG definition includes extensions specific to AMP.
        </t>
        <figure>
        <artwork>&lt;CODE BEGINS&gt; file "amp-extensions.yang"

<xi:include parse="text" href="amp-extensions.yang" />
&lt;CODE ENDS&gt;</artwork>
        </figure>
      </section>
    
      <section title="AMP Instances Submodule">
        <t>
        The following YANG definition includes extensions to define 
        AMP instance values.
        </t>
        <figure>
        <artwork>&lt;CODE BEGINS&gt; file "amp-instances.yang"

<xi:include parse="text" href="amp-instances.yang" />
&lt;CODE ENDS&gt;</artwork>
        </figure>
      </section>
      
    </section>
    
    <section title="Example Application Data Model">
      <t>
      The following YANG definition includes extensions specific to AMP.
      </t>
      <figure>
      <artwork>&lt;CODE BEGINS&gt; file ""example-adm.yang""

<xi:include parse="text" href="example-adm.yang" />
&lt;CODE ENDS&gt;</artwork>
      </figure>
    </section>
  </back>
</rfc>
